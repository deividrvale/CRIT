package equiv.ri

import equiv.ri.Equation.Side.Side
import equiv.trs.{Constraint, Rule, Term}

object Equation {
  object Side extends Enumeration {
    type Side = Value
    val Left, Right = Value
  }

  case class Equation(left: Term, right : Term, cons : Constraint) {
    def getSide(side: Side): Term = side match {
      case Side.Left => left
      case Side.Right => right
    }

    def getOppositeSide(side: Side): Term = side match {
      case Side.Left => right
      case Side.Right => left
    }

    def replaceSide(side: Side, term: Term): Equation = side match {
      case Side.Left => Equation(term, right, cons)
      case Side.Right => Equation(left, term, cons)
    }

    def applyAtSide(side: Side, f: Term => Term): Equation = side match {
      case Side.Left => Equation(f(left), right, cons)
      case Side.Right => Equation(left, f(right), cons)
    }

    /** TODO Get the Expd set of an equation */
    def getExpd(side: Side): Set[Equation] = Set()

    /** TODO Get the pairwise set of equalities for the constructor arguments in the equation */
    def getConstructorArguments: Set[Equation] = ???

    override def toString: String = s"$left ~~ $right $cons"

    /** Check if the rule generated by this equation is terminating. If so, return it in a set, otherwise return the empty set. */
    def maybeHypothesis(side: Side, rules: Set[Rule]): Set[Rule] = {
      val rule = Rule(this.getSide(side), this.getOppositeSide(side), Some(this.cons))
      if rule.isTerminating(rules) then Set(rule) else Set()
    }
  }
}
